#!/usr/bin/perl

# http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect
sub intersect {
	my ($p0_x, $p0_y, $p1_x, $p1_y, $p2_x, $p2_y, $p3_x, $p3_y) = @_;

	my ($s1_x, $s1_y, $s2_x, $s2_y);
	$s1_x = $p1_x - $p0_x;     $s1_y = $p1_y - $p0_y;
	$s2_x = $p3_x - $p2_x;     $s2_y = $p3_y - $p2_y;

	my ($s, $t);

	my $div = (-$s2_x * $s1_y + $s1_x * $s2_y);
	if ($div != 0) {
		$s = (-$s1_y * ($p0_x - $p2_x) + $s1_x * ($p0_y - $p2_y)) / $div;
	} else {
		return ();
	}

	$div = (-$s2_x * $s1_y + $s1_x * $s2_y);
	if ($div != 0) {
		$t = ( $s2_x * ($p0_y - $p2_y) - $s2_y * ($p0_x - $p2_x)) / $div;
	} else {
		return ();
	}

	if ($s >= 0 && $s <= 1 && $t >= 0 && $t <= 1) {
		return ($p0_x + ($t * $s1_x), $p0_y + ($t * $s1_y), $t);
	}

	return ();
}

# /*
#  * http://www.ecse.rpi.edu/~wrf/Research/Short_Notes/pnpoly.html#The C Code
#  *
#  * Copyright (c) 1970-2003, Wm. Randolph Franklin
#  *
#  * Permission is hereby granted, free of charge, to any person obtaining
#  * a copy of this software and associated documentation files (the
#  * "Software"), to deal in the Software without restriction, including
#  * without limitation the rights to use, copy, modify, merge, publish,
#  * distribute, sublicense, and/or sell copies of the Software, and to
#  * permit persons to whom the Software is furnished to do so, subject
#  * to the following conditions:
#  *
#  * Redistributions of source code must retain the above copyright notice,
#  * this list of conditions and the following disclaimers.
#  *
#  * Redistributions in binary form must reproduce the above copyright notice
#  * in the documentation and/or other materials provided with the distribution.
#  *
#  * The name of W. Randolph Franklin may not be used to endorse or promote
#  * products derived from this Software without specific prior written
#  * permission.
#  *
#  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
#  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
#  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
#  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
#  * DEALINGS IN THE SOFTWARE.
#  *
#  */
sub pnpoly {
	my ($testx, $testy, @poly) = @_;
	my $nvert = ($#poly + 1) / 2;
	my $c = 0;

	my ($i, $j);
	for ($i = 0, $j = $nvert - 1; $i < $nvert; $j = $i++) {
		if ((($poly[$i * 2 + 1] > $testy) != ($poly[$j * 2 + 1] > $testy)) &&
		     ($testx < ($poly[$j * 2] - $poly[$i * 2]) * ($testy - $poly[$i * 2 + 1]) / ($poly[$j * 2 + 1] - $poly[$i * 2 + 1]) + $poly[$i * 2])) {
			# XXX why does ! sometimes return an empty string?
			$c = !$c + 0;
		}
	}

	return $c;
}

sub clip {
	my ($x1, $y1, $x2, $y2, @poly) = @_;
	my @intersect = (0, 1);
	my @ret = ();

	my $i;
	my $j = $#poly - 1;
	for ($i = 0; $i <= $#poly; $j = $i, $i += 2) {
		my @i = intersect($x1, $y1, $x2, $y2, $poly[$j], $poly[$j + 1], $poly[$i], $poly[$i + 1]);

		if ($#i >= 0) {
			push @intersect, $i[2];
		}
	}

	@intersect = sort {$a <=> $b} (@intersect);

	for ($i = 0; $i < $#intersect; $i++) {
		my $mx = $x1 + ($x2 - $x1) * ($intersect[$i] + $intersect[$i + 1]) / 2;
		my $my = $y1 + ($y2 - $y1) * ($intersect[$i] + $intersect[$i + 1]) / 2;

		push @ret, $x1 + ($x2 - $x1) * $intersect[$i];
		push @ret, $y1 + ($y2 - $y1) * $intersect[$i];
		push @ret, $x1 + ($x2 - $x1) * $intersect[$i + 1];
		push @ret, $y1 + ($y2 - $y1) * $intersect[$i + 1];
		push @ret, pnpoly($mx, $my, @poly);
	}

	return @ret;
}

sub clipline {
	my ($x1, $y1, $x2, $y2) = @_;

	my @rects = ();
	#print "../datamaps/render -d -A -- northam-buffer.shape 20 $x1 $y1 $x2 $y2 |\n";
	open(IN, "../datamaps/render -d -A -- northam-buffer.shape 20 $x1 $y1 $x2 $y2 2>/dev/null |");
	while (<IN>) {
		push @rects, $_;
	}
	close(IN);

	my @intersect = (0, 1);

	my $n;
	for ($n = 0; $n <= $#rects; $n++) {
		# print "looking at polygon $rects[$n]\n";
		my @poly = ();
		my @points = split(/ /, $rects[$n]);
		for ($i = 0; $i <= $#points; $i++) {
			($lat, $lon) = split(/,/, $points[$i]);
			last unless $lat =~ /^[0-9.-]+$/;

			push @poly, $lat;
			push @poly, $lon;
		}

		my $i;
		my $j = $#poly - 1;
		for ($i = 0; $i <= $#poly; $j = $i, $i += 2) {
			my @i = intersect($x1, $y1, $x2, $y2, $poly[$j], $poly[$j + 1], $poly[$i], $poly[$i + 1]);

			if ($#i >= 0) {
				push @intersect, $i[2];
			}
		}
	}

	@intersect = sort {$a <=> $b} (@intersect);

	# print "$x1,$y1 to $x2,$y2 intersections are ";
	for ($i = 0; $i <= $#intersect; $i++) {
		# print "$intersect[$i]: ";
		my $mx = $x1 + ($x2 - $x1) * ($intersect[$i]);
		my $my = $y1 + ($y2 - $y1) * ($intersect[$i]);

		# print "$mx,$my ";
	}

	# print "\n";

	for ($i = 0; $i < $#intersect; $i++) {
		# print "i: $i\n";
		my $mx = $x1 + ($x2 - $x1) * ($intersect[$i] + $intersect[$i + 1]) / 2;
		my $my = $y1 + ($y2 - $y1) * ($intersect[$i] + $intersect[$i + 1]) / 2;

		my $ok = 1;
		for ($n = 0; ($n <= $#rects) && $ok; $n++) {
			# print "n: $n\n";
			my @poly = ();
			my @points = split(/ /, $rects[$n]);
			my $j;
			for ($j = 0; $j <= $#points; $j++) {
				($lat, $lon) = split(/,/, $points[$j]);
				last unless $lat =~ /^[0-9.-]+$/;

				push @poly, $lat;
				push @poly, $lon;
			}

			if (pnpoly($mx, $my, @poly)) {
				# print "$mx $my is in @poly\n";
				$ok = 0;
			}
		}

		if ($ok) {
			printf("%.6f,%.6f %.6f,%.6f // %d\n",
				$x1 + ($x2 - $x1) * $intersect[$i],
				$y1 + ($y2 - $y1) * $intersect[$i],
				$x1 + ($x2 - $x1) * $intersect[$i + 1],
				$y1 + ($y2 - $y1) * $intersect[$i + 1],
				$ok);
		}
	}
}

while (<>) {
	chomp;
	@points = split(/ /, $_);

	@lat = ();
	@lon = ();
	for ($i = 0; $i <= $#points; $i++) {
		($lat, $lon) = split(/,/, $points[$i]);
		last unless $lat =~ /^[0-9.-]+$/;

		$lat[$i] = $lat;
		$lon[$i] = $lon;
	}

	for ($i = 0; $i < $#lat; $i++) {
		clipline($lat[$i], $lon[$i], $lat[$i + 1], $lon[$i + 1]);
	}
}
